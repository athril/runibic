# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' This function calculates all pairwise LCSes within the array.
#'
#' This function computes unique pairwise Longest Common Subsequences within the matrix.
#'
#' @param discreteInput is a matrix
#' @return a list with informa
#'
#' @examples
#' calculateLCS(matrix(c(4,3,1,2,5,8,6,7),nrow=2,byrow=TRUE))
#'
NULL

#' Discretize an input matrix
#'
#' This function discretizes the input matrix
#' TODO: Implement functionality
#'
#' @param x a numeric matrix
#' @return a discretized matrix containing integers only
#'
discretize <- function(x) {
    .Call('_runibic_discretize', PACKAGE = 'runibic', x)
}

#' Computing the indexes of j-th smallest values of each row
#'
#' This function sorts separately each row of a numeric matrix and returns a matrix
#' in which the value in i-th row and j-th column represent the index of the j-th smallest value of the i-th row.
#'
#' @param x a numeric matrix
#' @return a numeric matrix with indexes indicating positions of j-th smallest element in each row
#'
#' @examples
#' unisort(matrix(c(4,3,1,2,5,8,6,7),nrow=2,byrow=TRUE))
#'
#' @export
unisort <- function(x) {
    .Call('_runibic_unisort', PACKAGE = 'runibic', x)
}

#' Calculating a matrix of Longest Common Subsequence (LCS) between a pair of numeric vectors
#'
#' This function calculates the matrix with Longest Common Subsequence (LCS)
#' between two numeric vectors.
#'
#' @param x an integer vector
#' @param y an integer vector
#' @return a matrix storing Longest Common Subsequence (LCS)
#'
#' @examples
#' pairwiseLCS(c(1,2,3,4,5),c(1,2,4))
#'
#' @export
pairwiseLCS <- function(x, y) {
    .Call('_runibic_pairwiseLCS', PACKAGE = 'runibic', x, y)
}

#' Retrieving from a matrix Longest Common Subsequence (LCS) between a pair of numeric vector.
#'
#' This function retrieves the Longest Common Subsequence (LCS)
#' between two numeric vectors by backtracking the matrix obtained with dynamic programming.
#'
#' @param x an integer vector
#' @param y an integer vector
#' @return an integer with the length of Longest Common Subsequence (LCS)
#'
#' @examples
#' backtrackLCS( c(1,2,3,4,5),c(1,2,4))
#'
#' @export
backtrackLCS <- function(x, y) {
    .Call('_runibic_backtrackLCS', PACKAGE = 'runibic', x, y)
}

#' Calculating biclusters from sorted list of LCS scores
#'
#' TODO: Make better parameters
#'
#' @param discreteInput an integer matrix
#' @param scores a numeric vector
#' @param geneOne a numeric vector
#' @param geneTwo a numeric vector
#' @param rowNumber a int with number of rows
#' @param colNumber a int with number of columns
#' @return a number of found clusters
#'
#' @examples
#' cluster(matrix(c(4,3,1,2,5,8,6,7,9,10,11,12),nrow=4,byrow=TRUE),c(13,12,11,7,5,3),c(0,1,2,0,0,1), c(3,2,3,2,1,3),4,3)
#'
#' @export
cluster <- function(discreteInput, scores, geneOne, geneTwo, rowNumber, colNumber) {
    .Call('_runibic_cluster', PACKAGE = 'runibic', discreteInput, scores, geneOne, geneTwo, rowNumber, colNumber)
}


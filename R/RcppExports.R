# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Set the parameters
#'
#' Runibic function for setting parameters
#'
#' @param t consistency level of the block (0.5-1.0] 
#' @param q a double value for quantile discretization
#' @param f filtering overlapping blocks, default 1(do not remove any blocks)
#' @param nbic maximum number of biclusters in output
#' @param div number of ranks as which we treat the up(down)-regulated value: default: 0==ncol(x)
#' @return NULL (an empty value)
#'
#' @examples
#' runibic_params(0.85,100,1,100,0)
#'
runibic_params <- function(t = 0.85, q = 0.5, f = 1, nbic = 100L, div = 0L) {
    invisible(.Call('_runibic_runibic_params', PACKAGE = 'runibic', t, q, f, nbic, div))
}

#' Discretize an input matrix
#'
#' This function discretizes the input matrix
#'
#' @param x a numeric matrix
#' @return a discretized matrix containing integers only
#'
#' @examples
#' A=replicate(10, rnorm(20))
#' discretize(A)
#'
discretize <- function(x) {
    .Call('_runibic_discretize', PACKAGE = 'runibic', x)
}

#' Computing the indexes of j-th smallest values of each row
#'
#' This function sorts separately each row of a numeric matrix and returns a matrix
#' in which the value in i-th row and j-th column represent the index of the j-th smallest value of the i-th row.
#'
#' @param x a numeric matrix
#' @return a numeric matrix with indexes indicating positions of j-th smallest element in each row
#'
#' @examples
#' A=matrix(c(4,3,1,2,5,8,6,7),nrow=2,byrow=TRUE)
#' unisort(A)
#'
#' @export
unisort <- function(x) {
    .Call('_runibic_unisort', PACKAGE = 'runibic', x)
}

#' Calculating a matrix of Longest Common Subsequence (LCS) between a pair of numeric vectors
#'
#' This function calculates the matrix with Longest Common Subsequence (LCS)
#' between two numeric vectors.
#'
#' @param x an integer vector
#' @param y an integer vector
#' @return a matrix storing Longest Common Subsequence (LCS)
#'
#' @examples
#' pairwiseLCS(c(1,2,3,4,5),c(1,2,4))
#'
#' @export
pairwiseLCS <- function(x, y) {
    .Call('_runibic_pairwiseLCS', PACKAGE = 'runibic', x, y)
}

#' Retrieving from a matrix Longest Common Subsequence (LCS) between a pair of numeric vector.
#'
#' This function retrieves the Longest Common Subsequence (LCS)
#' between two numeric vectors by backtracking the matrix obtained with dynamic programming.
#'
#' @param x an integer vector
#' @param y an integer vector
#' @return an integer with the length of Longest Common Subsequence (LCS)
#'
#' @examples
#' backtrackLCS( c(1,2,3,4,5),c(1,2,4))
#'
#' @export
backtrackLCS <- function(x, y) {
    .Call('_runibic_backtrackLCS', PACKAGE = 'runibic', x, y)
}

#' This function calculates all pairwise LCSes within the array.
#'
#' This function computes unique pairwise Longest Common Subsequences within the matrix.
#'
#' @param discreteInput is a matrix
#' @param useFibHeap boolean value if Fibonacci heap should be used for sorting and seeding
#' @return a list with informa
#'
#' @examples
#' calculateLCS(matrix(c(4,3,1,2,5,8,6,7),nrow=2,byrow=TRUE), TRUE)
#'
#' @export
calculateLCS <- function(discreteInput, useFibHeap) {
    .Call('_runibic_calculateLCS', PACKAGE = 'runibic', discreteInput, useFibHeap)
}

#' Calculating biclusters from sorted list of LCS scores
#'
#' TODO: Make better parameters
#'
#' @param discreteInput an integer matrix
#' @param scores a numeric vector
#' @param geneOne a numeric vector
#' @param geneTwo a numeric vector
#' @param rowNumber a int with number of rows
#' @param colNumber a int with number of columns
#' @return a number of found clusters
#'
#' @examples
#' cluster(matrix(c(4,3,1,2,5,8,6,7,9,10,11,12),nrow=4,byrow=TRUE),c(13,12,11,7,5,3),c(0,1,2,0,0,1), c(3,2,3,2,1,3),4,3)
#'
#' @export
cluster <- function(discreteInput, scores, geneOne, geneTwo, rowNumber, colNumber) {
    .Call('_runibic_cluster', PACKAGE = 'runibic', discreteInput, scores, geneOne, geneTwo, rowNumber, colNumber)
}

